(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{379:function(a,e,i){"use strict";i.r(e);var t=i(24),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,i=a._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[i("h2",{attrs:{id:"工作过程简介"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#工作过程简介"}},[a._v("#")]),a._v(" 工作过程简介")]),a._v(" "),i("p",[a._v("我们以一个普通的前端项目为例，项目中一般都会散落着各种各样的代码及资源文件，如下图所示：\n"),i("img",{attrs:{src:"/img/webpackproject.png",alt:"webpack"}}),a._v("\n比如 JS、CSS、图片、字体等，这些文件在 Webpack 的思想中都属于当前项目中的一个模块。Webpack 可以通过打包，将它们最终聚集到一起。Webpack 在整个打包的过程中：")]),a._v(" "),i("ul",[i("li",[a._v("通过 Loader 处理特殊类型资源的加载，例如加载样式、图片；")]),a._v(" "),i("li",[a._v("通过 Plugin 实现各种自动化的构建任务，例如自动压缩、自动发布。")])]),a._v(" "),i("p",[a._v("具体来看打包的过程，Webpack 启动后，会根据我们的配置，找到项目中的某个指定文件（一般这个文件都会是一个 JS 文件）作为入口。然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块，然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树，下面这个动画生动的演示了这个过程：\n"),i("img",{attrs:{src:"/img/loop.gif",alt:"webpack"}}),a._v("\n有了这个依赖关系树过后， Webpack 会遍历（递归）这个依赖树，找到每个节点对应的资源文件，然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中，从而实现整个项目的打包，具体操作可以参考下面的动画：\n"),i("img",{attrs:{src:"/img/loopdone.gif",alt:"webpack"}}),a._v("\n对于依赖模块中无法通过 JavaScript 代码表示的资源模块，例如图片或字体文件，一般的 Loader 会将它们单独作为资源文件拷贝到输出目录中，然后将这个资源文件所对应的访问路径作为这个模块的导出成员暴露给外部。")]),a._v(" "),i("p",[a._v("整个打包过程中，Loader 机制起了很重要的作用，因为如果没有 Loader 的话，Webpack 就无法实现各种各样类型的资源文件加载，那 Webpack 也就只能算是一个用来合并 JS 模块代码的工具了。")]),a._v(" "),i("h2",{attrs:{id:"工作原理剖析"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#工作原理剖析"}},[a._v("#")]),a._v(" 工作原理剖析")]),a._v(" "),i("ul",[i("li",[a._v("Webpack CLI 启动打包流程；")]),a._v(" "),i("li",[a._v("载入 Webpack 核心模块，创建 Compiler 对象；")]),a._v(" "),i("li",[a._v("使用 Compiler 对象开始编译整个项目；")]),a._v(" "),i("li",[a._v("从入口文件开始，解析模块依赖，形成依赖关系树；")]),a._v(" "),i("li",[a._v("递归依赖树，将每个模块交给对应的 Loader 处理；")]),a._v(" "),i("li",[a._v("合并 Loader 处理完的结果，将打包结果输出到 dist 目录。")])]),a._v(" "),i("h3",{attrs:{id:"webpack-cli"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#webpack-cli"}},[a._v("#")]),a._v(" webpack cli")]),a._v(" "),i("p",[a._v("这部分操作在 webpack-cli 的入口文件 bin/cli.js 中，这个文件中内容比较多，我们这里只截取部分核心代码，你可以对照截图中的行号找到源代码中对应的位置。")]),a._v(" "),i("p",[a._v("首先，Webpack CLI 会通过 yargs 模块web解析 CLI 参数，所谓 CLI 参数指的就是我们在运行 webpack 命令时通过命令行传入的参数，例如 --mode=production，具体位置如下：\n"),i("img",{attrs:{src:"/img/webpackcli.png",alt:"webpack"}}),a._v("\n紧接着后面，调用了 bin/utils/convert-argv.js 模块，将得到的命令行参数转换为 Webpack 的配置选项对象，具体操作如下：\n"),i("img",{attrs:{src:"/img/webpackcli2.png",alt:"webpack"}}),a._v("\n在 convert-argv.js 工作过程中，首先为传递过来的命令行参数设置了默认值，然后判断了命令行参数中是否指定了一个具体的配置文件路径，如果指定了就加载指定配置文件，反之则需要根据默认配置文件加载规则找到配置文件，具体代码如下：\n"),i("img",{attrs:{src:"/img/webpackcli3.png",alt:"webpack"}}),a._v("\n找到配置文件过后，将配置文件中的配置和 CLI 参数中的配置合并，如果出现重复的情况，会优先使用 CLI 参数，最终得到一个完整的配置选项。")]),a._v(" "),i("p",[a._v("有了配置选项过后，开始载入 Webpack 核心模块，传入配置选项，创建 Compiler 对象，这个 Compiler 对象就是整个 Webpack 工作过程中最核心的对象了，负责完成整个项目的构建工作。\n"),i("img",{attrs:{src:"/img/webpackcli4.png",alt:"webpack"}})]),a._v(" "),i("h3",{attrs:{id:"创建-compiler-对象"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#创建-compiler-对象"}},[a._v("#")]),a._v(" 创建 Compiler 对象")]),a._v(" "),i("p",[a._v("同样，这里我们需要找到这个模块的入口文件，也就是 lib/webpack.js 文件。这个文件导出的是一个用于创建 Compiler 的函数，具体如下：\n"),i("img",{attrs:{src:"/img/webpackcompiler.png",alt:"webpack"}}),a._v("\n在这个函数中，首先校验了外部传递过来的 options 参数是否符合要求，紧接着判断了 options 的类型。")]),a._v(" "),i("p",[a._v("根据这个函数中的代码，我们发现 options 不仅仅可以是一个对象，还可以是一个数组。如果我们传入的是一个数组，那么 Webpack 内部创建的就是一个 MultiCompiler，也就是说 Webpack 应该支持同时开启多路打包，配置数组中的每一个成员就是一个独立的配置选项。而如果我们传入的是普通的对象，就会按照我们最熟悉的方式创建一个 Compiler 对象，进行单线打包。\n"),i("img",{attrs:{src:"/img/webpackcompiler2.png",alt:"webpack"}}),a._v("\n我们顺着主线接着往下看，如下图所示：在创建了 Compiler 对象过后，Webpack 就开始注册我们配置中的每一个插件了，因为再往后 Webpack 工作过程的生命周期就要开始了，所以必须先注册，这样才能确保插件中的每一个钩子都能被命中。\n"),i("img",{attrs:{src:"/img/webpackcompiler3.png",alt:"webpack"}})]),a._v(" "),i("h3",{attrs:{id:"开始构建"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#开始构建"}},[a._v("#")]),a._v(" 开始构建")]),a._v(" "),i("p",[a._v("完成 Compiler 对象的创建过后，紧接着这里的代码开始判断配置选项中是否启用了监视模式，具体操作如下：\n"),i("img",{attrs:{src:"/img/webpackbuild.png",alt:"webpack"}})]),a._v(" "),i("ul",[i("li",[a._v("如果是监视模式就调用 Compiler 对象的 watch 方法，以监视模式启动构建，但这不是我们主要关心的主线。")]),a._v(" "),i("li",[a._v("如果不是监视模式就调用 Compiler 对象的 run 方法，开始构建整个应用。\n这个 run 方法定义在 Compiler 类型中，具体文件在 webpack 模块下的 lib/Compiler.js 中，代码位置如下：\n"),i("img",{attrs:{src:"/img/webpackbuild2.png",alt:"webpack"}}),a._v("\n这个方法内部就是先触发了beforeRun 和 run 两个钩子，然后最关键的是调用了当前对象的 compile 方法，真正开始编译整个项目，具体代码位置如下：\n"),i("img",{attrs:{src:"/img/webpackbuild3.png",alt:"webpack"}}),a._v("\ncompile 方法内部主要就是创建了一个 Compilation 对象\n"),i("img",{attrs:{src:"/img/webpackbuild4.png",alt:"webpack"}}),a._v("\n创建完 Compilation 对象过后，紧接着触发了一个叫作 make 的钩子，进入整个构建过程最核心的 make 阶段。")])]),a._v(" "),i("h3",{attrs:{id:"make-阶段"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#make-阶段"}},[a._v("#")]),a._v(" make 阶段")]),a._v(" "),i("p",[a._v("make 阶段主体的目标就是：根据 entry 配置找到入口模块，开始依次递归出所有依赖，形成依赖关系树，然后将递归到的每个模块交给不同的 Loader 处理。")]),a._v(" "),i("ul",[i("li",[a._v("SingleEntryPlugin 中调用了 Compilation 对象的 addEntry 方法，开始解析入口；")]),a._v(" "),i("li",[a._v("addEntry 方法中又调用了 _addModuleChain 方法，将入口模块添加到模块依赖列表中；")]),a._v(" "),i("li",[a._v("紧接着通过 Compilation 对象的 buildModule 方法进行模块构建；")]),a._v(" "),i("li",[a._v("buildModule 方法中执行具体的 Loader，处理特殊资源加载；")]),a._v(" "),i("li",[a._v("build 完成过后，通过 acorn 库生成模块代码的 AST 语法树；")]),a._v(" "),i("li",[a._v("根据语法树分析这个模块是否还有依赖的模块，如果有则继续循环 build 每个依赖；")]),a._v(" "),i("li",[a._v("所有依赖解析完成，build 阶段结束；")]),a._v(" "),i("li",[a._v("最后合并生成需要输出的 bundle.js 写入 dist 目录。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);