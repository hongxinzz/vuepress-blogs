(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{372:function(_,v,a){"use strict";a.r(v);var t=a(24),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"v8垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8垃圾回收"}},[_._v("#")]),_._v(" V8垃圾回收")]),_._v(" "),a("h2",{attrs:{id:"什么是内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是内存管理"}},[_._v("#")]),_._v(" 什么是内存管理")]),_._v(" "),a("blockquote",[a("p",[_._v("内存管理是控制和协调应用程序访问电脑内存的过程。这个过程是复杂的，对于我们来说，可以说相当于一个黑匣子")])]),_._v(" "),a("p",[_._v("当咱们的应用程序运行在某个操作系统中的时候，它访问电脑内存(RAM)来达成下列几个功能：")]),_._v(" "),a("ul",[a("li",[_._v("运行需要执行的字节码(代码)")]),_._v(" "),a("li",[_._v("存储程序运行时候所需的数据")]),_._v(" "),a("li",[_._v("加载程序运行所需的运行时环境\n上面用来存储程序运行时所需的数据，就是下面要说的堆(heap)和栈(stack)。")])]),_._v(" "),a("h2",{attrs:{id:"垃圾回收机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[_._v("#")]),_._v(" 垃圾回收机制")]),_._v(" "),a("h3",{attrs:{id:"标记清除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[_._v("#")]),_._v(" 标记清除")]),_._v(" "),a("blockquote",[a("p",[_._v("当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。")])]),_._v(" "),a("ul",[a("li",[_._v("垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）")]),_._v(" "),a("li",[_._v("然后，它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记")]),_._v(" "),a("li",[_._v("此后，依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了")]),_._v(" "),a("li",[_._v("最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间")])]),_._v(" "),a("h3",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[_._v("#")]),_._v(" 引用计数")]),_._v(" "),a("blockquote",[a("p",[_._v("核心思想： 设置引用数 判断引用数是否为0")])]),_._v(" "),a("ul",[a("li",[_._v("当有引用时 引用计数就会加1，反之引用减少时就会减1")]),_._v(" "),a("li",[_._v("当为0时GC就会开始工作，进行垃圾回收")])]),_._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[_._v("#")]),_._v(" 优点")]),_._v(" "),a("ul",[a("li",[_._v("发现垃圾时立即回收")]),_._v(" "),a("li",[_._v("最大限度减少程序暂停 注：内存将要爆满的时候，会立即去寻找为0的引用计数")])]),_._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[_._v("#")]),_._v(" 缺点")]),_._v(" "),a("ul",[a("li",[_._v("时间开销大")]),_._v(" "),a("li",[_._v("无法回收循环引用对象")])]),_._v(" "),a("h2",{attrs:{id:"栈-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack"}},[_._v("#")]),_._v(" 栈(stack)")]),_._v(" "),a("blockquote",[a("p",[_._v("顾名思义，是一种先进后出的结构，参考一下餐盘的取和放。")])]),_._v(" "),a("ul",[a("li",[_._v("由于先进后出性质，在数据的处理上栈有着很好的速度，因为只需从最顶部压栈和出栈就好了，简单明了。")]),_._v(" "),a("li",[_._v("不过，存储在栈中的数据必须是大小有限，生存期确定。")]),_._v(" "),a("li",[_._v("函数执行的时候会创建一个明确的栈，并压入，而当执行期间会存储函数内的所有数据，这就是栈帧。个人感觉可以理解为当前执行函数的快照。")]),_._v(" "),a("li",[_._v("多线程应用程序有多个栈。")]),_._v(" "),a("li",[_._v("栈的操作系统自动分配或释放。")]),_._v(" "),a("li",[_._v("存储在栈中的常见类型有：局部变量(值类型、基本类型、常量)、指针和函数")]),_._v(" "),a("li",[_._v("还记得平常偶尔遇到的stack overflow error吗？这是因为与堆相比，栈的大小受到了限制。大多属语言都是都是这样。")])]),_._v(" "),a("h2",{attrs:{id:"堆-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[_._v("#")]),_._v(" 堆(heap)")]),_._v(" "),a("blockquote",[a("p",[_._v("堆常用来动态内存分配，程序在堆中寻找数据需要使用指针。")])]),_._v(" "),a("ul",[a("li",[_._v("效率不如栈，但是可以存储更多的数据")]),_._v(" "),a("li",[_._v("可存储大小不确定的数据，如运行时确定")]),_._v(" "),a("li",[_._v("应用程序中多线程共享堆数据")]),_._v(" "),a("li",[_._v("堆由人工操作，故管理起来很棘手，可能会引起内存泄漏等问题，所以有很多语言有gc机制")]),_._v(" "),a("li",[_._v("存储在堆中的常见类型有：全局变量、引用类型和其他复杂的数据结构")]),_._v(" "),a("li",[_._v("这就是为什么你会遇到out of memory errors这类问题，因为用户的胡乱分配或者未销毁")]),_._v(" "),a("li",[_._v("我们分配给堆的数据其实并没有大小限制，理论上来说你可以分配无穷大的数据。当然如果这样你也得为应用程序分配这么多的内存。")])]),_._v(" "),a("h2",{attrs:{id:"v8引擎"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8引擎"}},[_._v("#")]),_._v(" V8引擎")]),_._v(" "),a("p",[_._v("V8在运行之前将JavaScript编译成了机器代码，而非字节码或是解释执行它，以此提升性能。V8使用C++书写，可以嵌入到任何C++应用程序中。")]),_._v(" "),a("h2",{attrs:{id:"v8内存结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8内存结构"}},[_._v("#")]),_._v(" V8内存结构")]),_._v(" "),a("p",[_._v("由于js是单线程的，所以node依然会为每个js环境提供单线程环境。如果你在服务端使用，他会为每个服务提供一个进程。在V8程序中，应用程序始终被分配的内存代表。这种内存成为常驻集")]),_._v(" "),a("h2",{attrs:{id:"v8中的堆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v8中的堆内存"}},[_._v("#")]),_._v(" V8中的堆内存")]),_._v(" "),a("blockquote",[a("p",[_._v("这里用来存储对象和动态数据，这是内存中最大的区域，并且是GC工作的地方。不过，并不是所有的堆内存都可以进行GC，只有新生代和老生代被gc管理。堆可以进一步细分为下面这样：")])]),_._v(" "),a("ul",[a("li",[_._v("新生代空间：是最新产生的数据存活的地方，这些数据往往都是短暂的。这个空间被一分为二，然后被Scavenger(Minor GC)所管理。稍后会介绍。可以通过V8标志如 --max_semi_space_size 或 --min_semi_space_size 来控制新生代空间大小")]),_._v(" "),a("li",[_._v("老生代空间：是从新生代空间经过至少两轮Minor GC仍然存活下来的数据，该空间被Major GC(Mark-Sweep & Mark-Compact)管理，稍后会介绍。可以通过 --initial_old_space_size 或 --max_old_space_size控制空间大小。\n"),a("ul",[a("li",[_._v("Old pointer space： 存活下来的包含指向其他对象指针的对象")]),_._v(" "),a("li",[_._v("Old data space： 存活下来的只包含数据的对象。")])])]),_._v(" "),a("li",[_._v("大对象空间： 这是比空间大小还要大的对象，大对象不会被gc处理。")]),_._v(" "),a("li",[_._v("代码空间：这里是JIT所编译的代码。这是除了在大对象空间中分配代码并执行之外的唯一可执行的空间。\n-map空间：存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);